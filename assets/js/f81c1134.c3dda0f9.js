"use strict";(self.webpackChunkmanurukavina=self.webpackChunkmanurukavina||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"java-is-boring","metadata":{"permalink":"/blog/java-is-boring","source":"@site/blog/2025-03-20-java-is-boring.md","title":"Java is Boring, That\'s the Best Thing About It","description":"Java often gets a bad rap for being \\"boring.\\" It lacks the flashy syntax of modern languages, doesn\'t have the hype of the latest frameworks, and rarely makes headlines. But that predictability is exactly what makes it one of the best choices for enterprise development.","date":"2025-03-20T00:00:00.000Z","tags":[],"readingTime":1.4,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"java-is-boring","title":"Java is Boring, That\'s the Best Thing About It"},"unlisted":false,"nextItem":{"title":"A Philosophy of Software Design, by John Ousterhout","permalink":"/blog/philosophy-by-john-ousterhout"}},"content":"Java often gets a bad rap for being \\"boring.\\" It lacks the flashy syntax of modern languages, doesn\'t have the hype of the latest frameworks, and rarely makes headlines. But that predictability is exactly what makes it one of the best choices for enterprise development.\\n\\n\x3c!-- truncate --\x3e\\n\\n### Stability Over Hype\\n\\nProgramming trends come and go. Every few years, a new language or framework takes the spotlight, promising to revolutionize development. Meanwhile, Java just keeps working. Large-scale enterprise applications, banking systems, and mission-critical software rely on Java because of its stability and long-term support.\\n\\nJava doesn\u2019t break every time a new version is released. Unlike some languages that introduce breaking changes frequently, Java maintains backward compatibility, ensuring that software written years ago can still run with minimal modifications.\\n\\n### Predictable Performance\\n\\nDevelopers love Java for its consistency. You don\u2019t have to worry about unpredictable memory leaks, inconsistent garbage collection, or strange runtime behavior. The JVM has been battle-tested for decades, making it one of the most reliable execution environments available.\\n\\nWhile newer languages try to optimize performance with fancy tricks, Java provides rock-solid performance that you can depend on. Sure, it may not be as \u201cexciting\u201d as low-level system programming or experimental languages, but when you\u2019re handling billions of transactions, excitement is the last thing you want.\\n\\n### The Power of Boring\\n\\nBoring means reliable. It means your code won\u2019t be obsolete in a year. It means companies can build on Java without worrying that their entire stack will need to be rewritten because of a sudden paradigm shift.\\n\\nJava is boring in the best way possible\u2014it just works. And in software development, that\u2019s worth more than any hype."},{"id":"philosophy-by-john-ousterhout","metadata":{"permalink":"/blog/philosophy-by-john-ousterhout","source":"@site/blog/2025-03-18-philosophy-by-john-ousterhout.md","title":"A Philosophy of Software Design, by John Ousterhout","description":"This should not have been a book\u2014for many reasons\u2014it could as well have been a bullet list. The summary I have at the end of this article is the whole book. Skip there if you don\u2019t care about my reasoning.","date":"2025-03-18T00:00:00.000Z","tags":[],"readingTime":4.515,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"philosophy-by-john-ousterhout","title":"A Philosophy of Software Design, by John Ousterhout"},"unlisted":false,"prevItem":{"title":"Java is Boring, That\'s the Best Thing About It","permalink":"/blog/java-is-boring"},"nextItem":{"title":"Audio Wave Processing in Assembly","permalink":"/blog/asm-audio"}},"content":"This should not have been a book\u2014for many reasons\u2014it could as well have been a bullet list. The summary I have at the end of this article is the whole book. Skip there if you don\u2019t care about my reasoning.\\n\\n\x3c!-- truncate --\x3e\\n\\nI first learned about John Ousterhout from a video on YouTube about Homa: a proposed better network protocol to replace TCP in data centers. A huge claim since TCP has stood the test of time despite its flaws; but John\u2019s approach to argumentation in the video made me go search for anything the man had written. My assumption was: \u201cIf he does this well in a lecture, how awesome would his publications and books be?\u201d That\u2019s how I landed on the book in the title of this post. Finally, I thought, some philosophizing on software and its design.\\n\\nIt was clear, from the book, that John has a wealth of experience. Somehow, that did not translate into how the book was written\u2014emphasis on \u201chow\u201d because the \u201cwhat\u201d had a lot of experience thrown into it. Why is this a concern? I did not see as much philosophy as marketed in the title of the book. The book read like something one of these new tech-bro-influencer types vibe-wrote on a live stream. Few central (and deep!) points, plenty of fluff.\\n\\n> **p.s. (aside):** When writing this article, I originally (mistakenly) named it \u201cPrinciples of Software Design\u201d because that\u2019s what I felt like I\u2019d just finished reading; not \u201cPhilosophy of\u2026\u201c\\n\\nIf this book was called \u201cPrinciples of\u2026\u201d or \u201cPostulates of\u2026\u201d, it would have read better. This is because the book is pretty much its headings.\\n\\n## Key Takeaways\\n\\n1. **Complexity is**\\n   - Caused by dependency and obscurity;\\n   - Witnessed as change amplification, cognitive load, and unknown unknowns.\\n2. **Modules should be deep.**\\n3. **Pay attention to the interfaces.**\\n4. **Document clearly and consistently; in comments and in code.**\\n5. **Iterate on design.**\\n\\nThese are the five points which stood out to me from the book; with the first, on complexity, being the center (and if you ask me, the only) point in this book. Around these points, John shows his experience with verbose examples. Now\u2026 there\u2019s a crowd for which such writing is required. My intuition (because an empirical lemma would require me to experiment) is that this crowd is those who rely heavily on memory and require constant repetition to memorize/learn. If you\u2019re in this crowd, this book is perfect. I reckon (again, an intuition) that true software engineers\u2014not the recent niche tutorial-baked crop\u2014are logical thinkers, in primo, able to deduce the end of a statement once its form becomes salient. To this bunch, this book will be a waste of time.\\n\\n---\\n\\n## My 10 Commandments of Software Design\\n**as inspired by John Ousterhout**\\n\\n1. If you must depend, depend explicitly.\\n2. Make the change simple, then make the simple change. *(Verbatim from Kent Beck)*\\n3. Deepen modules; for lesser cognitive load.\\n4. Start with documentation describing the what and why; not the how.\\n5. Beware of interfaces. Each one creates a new dependency.\\n6. Never intentionally obscure. Be consistently obvious to a fault.\\n7. Do not vibe code. Do a little design up front.\\n8. Document and iterate on your design.\\n9. Guard every changeset jealously. Complexity, like scope, creeps\u2026 until it\u2019s too large to handle.\\n10. Pull complexity downwards. Expose as little complexity to your users.\\n\\n---\\n\\n## Java Examples Illustrating Key Principles\\n\\n### 1. **If you must depend, depend explicitly.**\\n```java\\nclass Database {\\n    private final Connection connection;\\n\\n    public Database(Connection connection) {\\n        this.connection = connection;\\n    }\\n    \\n    public void query(String sql) {\\n        // Explicitly using the provided connection\\n        System.out.println(\\"Executing: \\" + sql);\\n    }\\n}\\n```\\n*Explicit dependency injection ensures flexibility and reduces hidden dependencies.*\\n\\n### 2. **Deepen modules; for lesser cognitive load.**\\n```java\\nclass UserService {\\n    private final UserRepository userRepository;\\n    \\n    public UserService(UserRepository userRepository) {\\n        this.userRepository = userRepository;\\n    }\\n    \\n    public User getUserDetails(String userId) {\\n        return userRepository.findUserById(userId);\\n    }\\n}\\n```\\n*A deep module provides a simple interface while encapsulating complexity.*\\n\\n### 3. **Beware of interfaces. Each one creates a new dependency.**\\n```java\\ninterface PaymentGateway {\\n    void processPayment(double amount);\\n}\\n\\nclass StripePayment implements PaymentGateway {\\n    public void processPayment(double amount) {\\n        System.out.println(\\"Processing payment with Stripe: \\" + amount);\\n    }\\n}\\n```\\n*Each interface must be carefully designed to avoid excessive dependencies.*\\n\\n### 4. **Do not vibe code. Do a little design up front.**\\n```java\\nclass ConfigLoader {\\n    private final Properties properties = new Properties();\\n    \\n    public ConfigLoader(String filePath) {\\n        try (FileInputStream fis = new FileInputStream(filePath)) {\\n            properties.load(fis);\\n        } catch (IOException e) {\\n            throw new RuntimeException(\\"Failed to load config\\", e);\\n        }\\n    }\\n    \\n    public String getConfig(String key) {\\n        return properties.getProperty(key);\\n    }\\n}\\n```\\n*A simple design decision upfront prevents future maintenance headaches.*\\n\\n---\\n\\n## Conclusion\\n\\nJohn Ousterhout\'s *A Philosophy of Software Design* offers valuable insights, but it lacks the depth and conciseness that would make it truly stand out. While the book is verbose, the core principles are solid and can be summarized in a few key points. If you prefer a more distilled and logical approach to software engineering, you may find the book unnecessary. However, if you thrive on repetition and detailed examples, it might be a useful read.\\n\\nThe Java examples above demonstrate how to apply some of these principles in practice. Whether or not you read the book, keeping these principles in mind will help you write better, more maintainable code."},{"id":"asm-audio","metadata":{"permalink":"/blog/asm-audio","source":"@site/blog/2025-03-17-asm-audio.md","title":"Audio Wave Processing in Assembly","description":"Audio processing at the assembly level was a cool challenge, merging DSP principles with the  control of low-level programming. here is how i did some stuff:","date":"2025-03-17T00:00:00.000Z","tags":[],"readingTime":2.865,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"asm-audio","title":"Audio Wave Processing in Assembly"},"unlisted":false,"prevItem":{"title":"A Philosophy of Software Design, by John Ousterhout","permalink":"/blog/philosophy-by-john-ousterhout"}},"content":"Audio processing at the assembly level was a cool challenge, merging DSP principles with the  control of low-level programming. here is how i did some stuff:\\n\\n\x3c!-- truncate --\x3e\\n\\n## Understanding Audio Waveforms\\n\\nAudio waves are typically represented as sequences of digital samples, which are discrete values representing the amplitude of the sound at a given time. These samples can be:\\n- **8-bit, 16-bit, or 32-bit integers** (PCM format)\\n- **Floating-point values**\\n- **Compressed formats (MP3, AAC)**, which require additional decoding steps\\n\\nFor assembly-level processing, we generally deal with PCM data, which is stored as signed or unsigned integers.\\n\\n## Processing Audio in Assembly\\n\\n### 1. Loading Audio Data\\n\\nBefore performing any processing, the audio file (e.g., WAV format) must be read into memory. This typically involves:\\n- Parsing the WAV header to extract sample rate, bit depth, and number of channels\\n- Allocating a buffer to hold raw PCM data\\n- Using system calls (like `read` in Linux or `ReadFile` in Windows) to load the data\\n\\n```assembly\\n; Example: x86-64 NASM to read a file into a buffer\\nmov rdi, file_descriptor    ; File descriptor\\nmov rsi, buffer            ; Destination buffer\\nmov rdx, buffer_size       ; Number of bytes to read\\nsyscall                    ; Invoke system call (Linux)\\n```\\n\\n### 2. Applying Basic Audio Effects\\n\\n#### a) Volume Control (Scaling Amplitude)\\nTo increase or decrease volume, we scale each sample by a factor:\\n\\n```assembly\\n; Assuming 16-bit signed PCM data in an array\\nmov ax, [buffer]          ; Load sample\\nimul ax, volume_factor    ; Scale amplitude\\nsar ax, 8                 ; Normalize (assuming factor is 8-bit fixed point)\\nmov [buffer], ax          ; Store modified sample\\n```\\n\\n#### b) Echo Effect (Delayed Addition)\\nAn echo effect can be implemented by mixing delayed samples with the original waveform:\\n\\n```assembly\\n; Simple echo: y[n] = x[n] + 0.5 * x[n - delay]\\nmov ax, [buffer + delay]   ; Fetch old sample\\nsar ax, 1                  ; Scale by 0.5\\nadd [buffer], ax           ; Mix with current sample\\n```\\n\\n### 3. FFT for Frequency Analysis\\nFor frequency-domain processing (e.g., equalizers, reverb), we use the **Fast Fourier Transform (FFT)**. Implementing FFT in assembly involves:\\n1. Bit-reversal permutation of input samples\\n2. Iterative butterfly operations for DFT computation\\n3. Applying windowing and scaling as needed\\n\\nThough a full FFT implementation is complex, an optimized **SIMD (Single Instruction, Multiple Data) approach** using **AVX or SSE** instructions can significantly speed up processing.\\n\\n```assembly\\n; Simplified SSE-based addition of two audio sample arrays\\nmovaps xmm0, [buffer1]   ; Load 4 float samples\\nmovaps xmm1, [buffer2]   ; Load another set\\naddps xmm0, xmm1         ; Perform parallel addition\\nmovaps [buffer_out], xmm0 ; Store result\\n```\\n\\n### 4. Writing Processed Audio Back\\nAfter processing, the modified PCM data must be written back to an output file. This follows the same procedure as reading but in reverse:\\n- Open a new file for writing\\n- Write the WAV header\\n- Write PCM data using system calls\\n\\n```assembly\\n; Write buffer to file\\nmov rdi, output_fd       ; Output file descriptor\\nmov rsi, buffer          ; Buffer containing PCM data\\nmov rdx, buffer_size     ; Number of bytes to write\\nsyscall                  ; Invoke write system call\\n```\\n\\n## Optimizing Performance\\nSince audio processing is computationally intensive, optimization techniques include:\\n- **Using SIMD instructions (SSE/AVX) for parallel processing**\\n- **Loop unrolling** to reduce branching overhead\\n- **Efficient memory access** to minimize cache misses\\n- **Fixed-point arithmetic** to avoid floating-point overhead on low-power systems\\n\\nThanks for reading :)"}]}}')}}]);