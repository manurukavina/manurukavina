<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://manurukavina.com/blog</id>
    <title>Manu Rukavina Blog</title>
    <updated>2025-03-17T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://manurukavina.com/blog"/>
    <subtitle>Manu Rukavina Blog</subtitle>
    <icon>https://manurukavina.com/https://github.com/manurukavina.png</icon>
    <entry>
        <title type="html"><![CDATA[Audio Wave Processing in Assembly]]></title>
        <id>https://manurukavina.com/blog/asm-audio</id>
        <link href="https://manurukavina.com/blog/asm-audio"/>
        <updated>2025-03-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Audio processing at the assembly level was a cool challenge, merging DSP principles with the  control of low-level programming. here is how i did some stuff:]]></summary>
        <content type="html"><![CDATA[<p>Audio processing at the assembly level was a cool challenge, merging DSP principles with the  control of low-level programming. here is how i did some stuff:</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-audio-waveforms">Understanding Audio Waveforms<a href="https://manurukavina.com/blog/asm-audio#understanding-audio-waveforms" class="hash-link" aria-label="Direct link to Understanding Audio Waveforms" title="Direct link to Understanding Audio Waveforms">​</a></h2>
<p>Audio waves are typically represented as sequences of digital samples, which are discrete values representing the amplitude of the sound at a given time. These samples can be:</p>
<ul>
<li><strong>8-bit, 16-bit, or 32-bit integers</strong> (PCM format)</li>
<li><strong>Floating-point values</strong></li>
<li><strong>Compressed formats (MP3, AAC)</strong>, which require additional decoding steps</li>
</ul>
<p>For assembly-level processing, we generally deal with PCM data, which is stored as signed or unsigned integers.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="processing-audio-in-assembly">Processing Audio in Assembly<a href="https://manurukavina.com/blog/asm-audio#processing-audio-in-assembly" class="hash-link" aria-label="Direct link to Processing Audio in Assembly" title="Direct link to Processing Audio in Assembly">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-loading-audio-data">1. Loading Audio Data<a href="https://manurukavina.com/blog/asm-audio#1-loading-audio-data" class="hash-link" aria-label="Direct link to 1. Loading Audio Data" title="Direct link to 1. Loading Audio Data">​</a></h3>
<p>Before performing any processing, the audio file (e.g., WAV format) must be read into memory. This typically involves:</p>
<ul>
<li>Parsing the WAV header to extract sample rate, bit depth, and number of channels</li>
<li>Allocating a buffer to hold raw PCM data</li>
<li>Using system calls (like <code>read</code> in Linux or <code>ReadFile</code> in Windows) to load the data</li>
</ul>
<div class="language-assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-assembly codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">; Example: x86-64 NASM to read a file into a buffer</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rdi, file_descriptor    ; File descriptor</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rsi, buffer            ; Destination buffer</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rdx, buffer_size       ; Number of bytes to read</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">syscall                    ; Invoke system call (Linux)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-applying-basic-audio-effects">2. Applying Basic Audio Effects<a href="https://manurukavina.com/blog/asm-audio#2-applying-basic-audio-effects" class="hash-link" aria-label="Direct link to 2. Applying Basic Audio Effects" title="Direct link to 2. Applying Basic Audio Effects">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="a-volume-control-scaling-amplitude">a) Volume Control (Scaling Amplitude)<a href="https://manurukavina.com/blog/asm-audio#a-volume-control-scaling-amplitude" class="hash-link" aria-label="Direct link to a) Volume Control (Scaling Amplitude)" title="Direct link to a) Volume Control (Scaling Amplitude)">​</a></h4>
<p>To increase or decrease volume, we scale each sample by a factor:</p>
<div class="language-assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-assembly codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">; Assuming 16-bit signed PCM data in an array</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov ax, [buffer]          ; Load sample</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">imul ax, volume_factor    ; Scale amplitude</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">sar ax, 8                 ; Normalize (assuming factor is 8-bit fixed point)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov [buffer], ax          ; Store modified sample</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="b-echo-effect-delayed-addition">b) Echo Effect (Delayed Addition)<a href="https://manurukavina.com/blog/asm-audio#b-echo-effect-delayed-addition" class="hash-link" aria-label="Direct link to b) Echo Effect (Delayed Addition)" title="Direct link to b) Echo Effect (Delayed Addition)">​</a></h4>
<p>An echo effect can be implemented by mixing delayed samples with the original waveform:</p>
<div class="language-assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-assembly codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">; Simple echo: y[n] = x[n] + 0.5 * x[n - delay]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov ax, [buffer + delay]   ; Fetch old sample</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">sar ax, 1                  ; Scale by 0.5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">add [buffer], ax           ; Mix with current sample</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-fft-for-frequency-analysis">3. FFT for Frequency Analysis<a href="https://manurukavina.com/blog/asm-audio#3-fft-for-frequency-analysis" class="hash-link" aria-label="Direct link to 3. FFT for Frequency Analysis" title="Direct link to 3. FFT for Frequency Analysis">​</a></h3>
<p>For frequency-domain processing (e.g., equalizers, reverb), we use the <strong>Fast Fourier Transform (FFT)</strong>. Implementing FFT in assembly involves:</p>
<ol>
<li>Bit-reversal permutation of input samples</li>
<li>Iterative butterfly operations for DFT computation</li>
<li>Applying windowing and scaling as needed</li>
</ol>
<p>Though a full FFT implementation is complex, an optimized <strong>SIMD (Single Instruction, Multiple Data) approach</strong> using <strong>AVX or SSE</strong> instructions can significantly speed up processing.</p>
<div class="language-assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-assembly codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">; Simplified SSE-based addition of two audio sample arrays</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">movaps xmm0, [buffer1]   ; Load 4 float samples</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">movaps xmm1, [buffer2]   ; Load another set</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">addps xmm0, xmm1         ; Perform parallel addition</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">movaps [buffer_out], xmm0 ; Store result</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-writing-processed-audio-back">4. Writing Processed Audio Back<a href="https://manurukavina.com/blog/asm-audio#4-writing-processed-audio-back" class="hash-link" aria-label="Direct link to 4. Writing Processed Audio Back" title="Direct link to 4. Writing Processed Audio Back">​</a></h3>
<p>After processing, the modified PCM data must be written back to an output file. This follows the same procedure as reading but in reverse:</p>
<ul>
<li>Open a new file for writing</li>
<li>Write the WAV header</li>
<li>Write PCM data using system calls</li>
</ul>
<div class="language-assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-assembly codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">; Write buffer to file</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rdi, output_fd       ; Output file descriptor</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rsi, buffer          ; Buffer containing PCM data</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">mov rdx, buffer_size     ; Number of bytes to write</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">syscall                  ; Invoke write system call</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="optimizing-performance">Optimizing Performance<a href="https://manurukavina.com/blog/asm-audio#optimizing-performance" class="hash-link" aria-label="Direct link to Optimizing Performance" title="Direct link to Optimizing Performance">​</a></h2>
<p>Since audio processing is computationally intensive, optimization techniques include:</p>
<ul>
<li><strong>Using SIMD instructions (SSE/AVX) for parallel processing</strong></li>
<li><strong>Loop unrolling</strong> to reduce branching overhead</li>
<li><strong>Efficient memory access</strong> to minimize cache misses</li>
<li><strong>Fixed-point arithmetic</strong> to avoid floating-point overhead on low-power systems</li>
</ul>
<p>Thanks for reading :)</p>]]></content>
    </entry>
</feed>